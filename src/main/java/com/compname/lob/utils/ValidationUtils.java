package com.compname.lob.utils;

import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.collections.MapUtils;
import org.apache.commons.lang3.StringUtils;


import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.compname.lob.domain.config.AbstractProperties;
import com.compname.lob.domain.config.EnvironmentTypes;
import com.compname.lob.domain.config.PlanMappingLength;
import com.compname.lob.domain.workorder.AbstractWorkOrder;
import com.compname.lob.domain.workorder.EligibilityWorkOrder;

/**
 * PropertyValidationUtils
 * 
 * @author vegirl1
 * @since Jul 7, 2015
 * @version $Revision$
 */
public final class ValidationUtils {

    private static final String SYSTEM_PROPERTY_RUNENV     = "runEnv";
    private static final String CERTIFICATE_FORMAT_PATTERN = "^\\d{0,9}$";

    /**
     * getRuntimeEnvironment
     * 
     */
    public static String getRuntimeEnvironment() {
        String env = System.getProperty(SYSTEM_PROPERTY_RUNENV);
        if (StringUtils.isEmpty(env)) {
            env = EnvironmentTypes.LOCAL.getValue();
        }
        return env;

    }

    public static boolean isMapListEmpty(Map<String, List<List<String>>> mapList) {
        boolean isEmpty = true;
        if (MapUtils.isNotEmpty(mapList)) {
            for (String key : mapList.keySet()) {
                for (List<String> values : mapList.get(key)) {
                    isEmpty = CollectionUtils.isEmpty(values);
                }
            }
        }
        return isEmpty;
    }

    public static List<String> getListElementsByIndex(List<List<String>> listLists, int startIndex, int endIndex, String delimiter,
            int leftPadZeroLength) {
        List<String> listElement = Lists.newArrayList();
        try {
            for (List<String> values : listLists) {
                String element = StringUtils.EMPTY;
                for (int i = startIndex; i <= endIndex; i++) {

                    if (leftPadZeroLength > 0) {
                        element += StringUtils.leftPad(values.get(i), leftPadZeroLength, "0");
                    } else {
                        element += values.get(i);
                    }

                    if (i <= endIndex - 1) {
                        element += delimiter;
                    }
                }
                listElement.add(element);
            }
        } catch (IndexOutOfBoundsException iobe) {
            listElement = Lists.newArrayList();
        }
        return listElement;
    }

    public static boolean hasDuplicateOldNewCertificateNumber(List<List<String>> certMaps) {

        boolean hasDuplicate = false;
        // old Certificate
        List<String> certList = ValidationUtils.getListElementsByIndex(certMaps, 0, 0, StringUtils.EMPTY, 0);
        Set<String> tmpSet = Sets.newHashSet(certList);
        hasDuplicate = certMaps.size() != tmpSet.size();

        if (!hasDuplicate) {
            // new Certificate
            certList = ValidationUtils.getListElementsByIndex(certMaps, 1, 1, StringUtils.EMPTY, 0);
            tmpSet = Sets.newHashSet(certList);
            hasDuplicate = certMaps.size() != tmpSet.size();

        }

        return hasDuplicate;
    }

    public static boolean isNotValidOldNewCertificateNumber(EligibilityWorkOrder workOrder) {
        boolean isNotValidCertNumber = false;
        if (AbstractWorkOrder.YES_FLAGS_LIST.contains(workOrder.getCertConversionRequired())
                && AbstractWorkOrder.NO_FLAGS_LIST.contains(workOrder.getCertAutoGenerated())) {
            for (String key : workOrder.getCertificateMaps().keySet()) {
                List<List<String>> certMaps = workOrder.getCertificateMaps().get(key);
                for (List<String> values : certMaps) {
                    if (values.size() != 2) {
                        isNotValidCertNumber = true;
                        break;
                    }
                    Iterable<String> validCertificates = Iterables.filter(values, new Predicate<String>() {
                        public boolean apply(String input) {
                            return StringUtils.isEmpty(input) ? false : input.matches(CERTIFICATE_FORMAT_PATTERN);
                        }
                    });
                    if (Iterables.size(validCertificates) != values.size()) {
                        isNotValidCertNumber = true;
                        break;
                    }
                }

                if (!isNotValidCertNumber) {
                    isNotValidCertNumber = ValidationUtils.hasDuplicateOldNewCertificateNumber(certMaps);
                }
            }
        }
        return isNotValidCertNumber;
    }

    public static boolean hasPlanMapping(EligibilityWorkOrder workOrder, final String planType) {
        List<String> planTypes = Lists.newArrayList(workOrder.getPlanMaps().keySet());

        boolean hasPlan = false;
        for (String key : getPlanMapping(planTypes, planType)) {
            if (CollectionUtils.isNotEmpty(workOrder.getPlanMaps().get(key))) {
                hasPlan = true;
                break;
            }
        }
        return hasPlan;
    }

    public static Iterable<String> getPlanMapping(List<String> planTypes, final String planType) {
        Iterable<String> types = Iterables.filter(planTypes, new Predicate<String>() {
            public boolean apply(String input) {
                return StringUtils.contains(input, planType);
            }
        });

        return types;
    }

    public static boolean isNotValidPlanMapValues(Map<String, List<List<String>>> planMaps) {

        boolean isNotValidPlan = false;
        List<String> allPlans = Lists.newArrayList();
        for (String key : planMaps.keySet()) {

            List<List<String>> plans = planMaps.get(key);

            List<String> listAccClas = ValidationUtils.getListElementsByIndex(plans, 1, 2, AbstractProperties.UNDERSCORE, 0);
            Set<String> tmpSet = Sets.newHashSet(listAccClas);
            if (plans.size() != tmpSet.size()) {
                isNotValidPlan = true;
                break;
            }

            if (isNotValidPlanMapValueLength(plans)) {
                isNotValidPlan = true;
                break;
            }

            for (List<String> values : plans) {
                List<String> dummyLists = Lists.newArrayList(values);
                // skip first value (SLAC group number) that might be null
                dummyLists.remove(0);
                allPlans.addAll(dummyLists);
            }

        }

        if (!isNotValidPlan && allPlans.contains(null)) {
            isNotValidPlan = true;
        }

        return isNotValidPlan;
    }

    public static boolean isNotValidPlanMapValueLength(List<List<String>> plans) {

        boolean isNotValidPlan = false;

        for (PlanMappingLength planValue : PlanMappingLength.values()) {

            int index = Integer.valueOf(planValue.getTabIndex()).intValue();
            final int fieldLength = Integer.valueOf(planValue.getFieldLength()).intValue();
            List<String> elements = ValidationUtils.getListElementsByIndex(plans, index, index, StringUtils.EMPTY, 0);

            Iterable<String> checkedElements = Iterables.filter(elements, new Predicate<String>() {
                public boolean apply(String input) {
                    return StringUtils.isEmpty(input) || input.length() <= fieldLength;
                }
            });

            if (elements.size() != Iterables.size(checkedElements)) {
                isNotValidPlan = true;
                break;
            }
        }

        return isNotValidPlan;
    }

    public static <T extends AbstractProperties> void validateStreamProperties(T config) throws ServiceException {

        List<ErrorInfo> errorInfos = Lists.newLinkedList();

        if (StringUtils.isEmpty(config.getMaincursorDataSource())) {
            errorInfos.add(ErrorInfo.createWith("ValidationUtil.validateStreamProperties()",
                    AbstractProperties.FAMILY_GROUP_BENEFIT, ErrorInfo.ERROR,
                    "Datasource for list of WorkOrderKey to generate reports for is Empty"));
        }

        if (StringUtils.isEmpty(config.getOutputPath())) {
            errorInfos.add(ErrorInfo.createWith("ValidationUtil.validateStreamProperties()",
                    AbstractProperties.FAMILY_GROUP_BENEFIT, ErrorInfo.ERROR, "Output Path is Empty"));
        }

        if (CollectionUtils.isEmpty(config.getFilesToCreate())) {
            errorInfos.add(ErrorInfo.createWith("ValidationUtil.validateStreamProperties()",
                    AbstractProperties.FAMILY_GROUP_BENEFIT, ErrorInfo.ERROR, "File Names list to be createed is Empty"));
        }

        if (MapUtils.isEmpty(config.getFileSheetNames())) {
            errorInfos.add(ErrorInfo.createWith("ValidationUtil.validateStreamProperties()",
                    AbstractProperties.FAMILY_GROUP_BENEFIT, ErrorInfo.ERROR, "File sheet names list is Empty"));
        }

        if (MapUtils.isEmpty(config.getFileNames())) {
            errorInfos.add(ErrorInfo.createWith("ValidationUtil.validateStreamProperties()",
                    AbstractProperties.FAMILY_GROUP_BENEFIT, ErrorInfo.ERROR, "File names list is Empty"));
        }

        if (MapUtils.isEmpty(config.getFileSheetHeaders())) {
            errorInfos.add(ErrorInfo.createWith("ValidationUtil.validateStreamProperties()",
                    AbstractProperties.FAMILY_GROUP_BENEFIT, ErrorInfo.ERROR, "File sheet headers list is Empty"));
        }

        if (MapUtils.isEmpty(config.getDatasourceNames())) {
            errorInfos.add(ErrorInfo.createWith("ValidationUtil.validateStreamProperties()",
                    AbstractProperties.FAMILY_GROUP_BENEFIT, ErrorInfo.ERROR, "DataSource names list is Empty"));
        }

        if (CollectionUtils.isEmpty(config.getParameters())) {
            errorInfos.add(ErrorInfo.createWith("ValidationUtil.validateStreamProperties()",
                    AbstractProperties.FAMILY_GROUP_BENEFIT, ErrorInfo.ERROR, "Parameters list is Empty"));
        }

        if (CollectionUtils.isNotEmpty(errorInfos)) {
            throw new ServiceException("Stream ('" + config.getClass().getSimpleName() + "') Properties are not valid", errorInfos);
        }
    }
}
